#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D output_tex;


layout(location = 0) uniform vec2 resolution;
layout(location = 1) uniform vec3 cam_pos;
layout(location = 2) uniform mat3 rotation;
layout(location = 3) uniform int tree[16000];


vec3 poses[8] = {
	vec3( 0.5, 0.5, 0.5),
	vec3(-0.5, 0.5, 0.5),
	vec3( 0.5,-0.5, 0.5),
	vec3(-0.5,-0.5, 0.5),
	vec3( 0.5, 0.5,-0.5),
	vec3(-0.5, 0.5,-0.5),
	vec3( 0.5,-0.5,-0.5),
	vec3(-0.5,-0.5,-0.5)
};


//#define get_tree_data(fst) ((uint(tree[(fst)/2]) >> ((fst & 1) * 16)) & 0xffff)


bool ray_box(vec3 ro, vec3 rd, float size, out float t) {
	float idx = 1. / rd.x;
	float idy = 1. / rd.y;
	float idz = 1. / rd.z;

	float t1 = (-size - ro.x) * idx;
	float t2 = ( size - ro.x) * idx;
	float t3 = (-size - ro.y) * idy;
	float t4 = ( size - ro.y) * idy;
	float t5 = (-size - ro.z) * idz;
	float t6 = ( size - ro.z) * idz;

	float tmin = max(max(min(t1,t2), min(t3,t4)), min(t5,t6));
	float tmax = min(min(max(t1,t2), max(t3,t4)), max(t5,t6));

	t = tmin;

	return tmax >= 0 && tmin < tmax;
}



uint stack_fst[512];
vec3 stack_pos[512];
float stack_size[512];
float stack_t[512];

uint sp = 0;

void push(in uint fst, in vec3 pos, in float size, in float t) {
	stack_fst[sp] = fst;
	stack_pos[sp] = pos;
	stack_size[sp] = size;
	stack_t[sp] = t;
	sp++;
}

void pop(out uint fst, out vec3 pos, out float size, out float t) {
	sp--;
	fst = stack_fst[sp];
	pos = stack_pos[sp];
	size = stack_size[sp];
	t = stack_t[sp];
}


void main() {
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

	vec2 uv = gl_GlobalInvocationID.xy / resolution * 2 - 1;

	vec3 rd = normalize(vec3(uv,1)) * rotation;
	vec3 ro = cam_pos;

	vec4 color = vec4(0);


	float tmin = 1./0.;
	float root_t;
	float root_size = 64;


	if (ray_box(ro, rd, root_size, root_t))
		push(0, vec3(0), root_size*0.5, root_t);


	uint iters = 0;

	while (sp > 0 && iters < 100) {
		iters++;

		uint fst;
		vec3 pos;
		float size;
		float t;

		pop(fst,pos,size,t);


		int data = tree[fst];

		int group_offset = data >> 16;
		int childs = (data & 0xff00) >> 8;
		int leafs = data & 0xff;

		int cfst = 0;

		//color += vec4(0.05);

		size *= 0.5;

		for (int i = 0; i < 8; i++) {
			vec3 dp = poses[i] * size*2;

			bool empty = (childs & (1 << i)) == 0;
			bool leaf =  ( leafs & (1 << i)) != 0;

			if (empty)
				continue;

			if (!ray_box(ro+pos+dp,rd, size, t)) {
				if (!leaf)
					cfst++;

				continue;
			}

			if (leaf) {
				tmin = min(t,tmin);
				if (t > tmin)
					continue;
				color = vec4(1./t+0.1);
				//break;
			} else {
				push(group_offset+cfst, pos+dp, size, t);
				cfst++;
			}
		}
	}


	imageStore(output_tex, pos, color);
}
