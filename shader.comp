#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D output_tex;


layout(location = 0) uniform vec2 resolution;
layout(location = 1) uniform vec3 cam_pos;
layout(location = 2) uniform mat3 rotation;
layout(location = 3) uniform int tree[1000];


#define get_tree_data(fst) ((uint(tree[(fst)/2]) >> ((fst & 1) * 16)) & 0xffff)


bool ray_box(vec3 ro, vec3 rd, float size, out float t) {
	float idx = 1. / rd.x;
	float idy = 1. / rd.y;
	float idz = 1. / rd.z;

	float t1 = (-size - ro.x) * idx;
	float t2 = ( size - ro.x) * idx;
	float t3 = (-size - ro.y) * idy;
	float t4 = ( size - ro.y) * idy;
	float t5 = (-size - ro.z) * idz;
	float t6 = ( size - ro.z) * idz;

	float tmin = max(max(min(t1,t2), min(t3,t4)), min(t5,t6));
	float tmax = min(min(max(t1,t2), max(t3,t4)), max(t5,t6));

	t = tmin;

	return tmax >= 0 && tmin < tmax;
}



uint stack_fst[512];
vec3 stack_pos[512];
uint stack_level[512];
float stack_t[512];

uint sp = 0;

void push(in uint fst, in vec3 pos, in uint level, in float t) {
	stack_fst[sp] = fst;
	stack_pos[sp] = pos;
	stack_level[sp] = level;
	stack_t[sp] = t;
	sp++;
}

void pop(out uint fst, out vec3 pos, out uint level, out float t) {
	sp--;
	fst = stack_fst[sp];
	pos = stack_pos[sp];
	level = stack_level[sp];
	t = stack_t[sp];
}


void main() {
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

	vec2 uv = gl_GlobalInvocationID.xy / resolution * 2 - 1;

	vec3 rd = normalize(vec3(uv,1)) * rotation;
	vec3 ro = cam_pos;

	vec4 color = vec4(0.2,0.4,0.8,1) * 255;


	float tmin = 1./0.;
	float root_t;


	if (ray_box(ro, rd, 1<<4, root_t))
		push(0, vec3(0), 4, root_t);


	uint iters = 0;

	while (sp > 0 && iters < 100) {
		iters++;

		uint fst;
		vec3 pos;
		uint level;
		float t;

		pop(fst,pos,level,t);

		float size = 1 << level;

		uint childs = get_tree_data(fst);

		if (level == 0 || childs == 0) {
			tmin = min(t,tmin);

			color = mix(color, vec4(
				get_tree_data(fst+1),
				get_tree_data(fst+2),
				get_tree_data(fst+3),
			255), step(t,tmin));
		} else {
			for (int i = 0; i < 8; i++) {
				if ((childs & (1 << i)) != 0) {
					fst++;
					vec3 dp = (vec3(i&1,(i&2)>>1,(i&4)>>2) - vec3(0.5)) * size;

					if (ray_box(ro+pos+dp, rd, 1<<(level-1), t))
						push(get_tree_data(fst), pos+dp, level-1, t);
				}
			}
		}
	}


	imageStore(output_tex, pos, color / 255);
}
